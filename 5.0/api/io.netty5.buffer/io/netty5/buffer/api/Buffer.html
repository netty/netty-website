<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.10) on Mon May 16 13:40:32 PDT 2022 -->
<title>Buffer (Netty API Reference (5.0.0.Alpha2))</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2022-05-16">
<meta name="keywords" content="io.netty5.buffer.api.Buffer interface">
<meta name="keywords" content="capacity()">
<meta name="keywords" content="readerOffset()">
<meta name="keywords" content="skipReadable()">
<meta name="keywords" content="writerOffset()">
<meta name="keywords" content="skipWritable()">
<meta name="keywords" content="readableBytes()">
<meta name="keywords" content="writableBytes()">
<meta name="keywords" content="fill()">
<meta name="keywords" content="makeReadOnly()">
<meta name="keywords" content="readOnly()">
<meta name="keywords" content="isDirect()">
<meta name="keywords" content="implicitCapacityLimit()">
<meta name="keywords" content="copyInto()">
<meta name="keywords" content="transferTo()">
<meta name="keywords" content="transferFrom()">
<meta name="keywords" content="writeCharSequence()">
<meta name="keywords" content="readCharSequence()">
<meta name="keywords" content="writeBytes()">
<meta name="keywords" content="readBytes()">
<meta name="keywords" content="resetOffsets()">
<meta name="keywords" content="bytesBefore()">
<meta name="keywords" content="openCursor()">
<meta name="keywords" content="openReverseCursor()">
<meta name="keywords" content="ensureWritable()">
<meta name="keywords" content="copy()">
<meta name="keywords" content="readSplit()">
<meta name="keywords" content="writeSplit()">
<meta name="keywords" content="split()">
<meta name="keywords" content="compact()">
<meta name="keywords" content="countComponents()">
<meta name="keywords" content="countReadableComponents()">
<meta name="keywords" content="countWritableComponents()">
<meta name="keywords" content="forEachReadable()">
<meta name="keywords" content="forEachWritable()">
<meta name="keywords" content="toString()">
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Buffer (Netty API Reference (5.0.0.Alpha2))";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":6,"i1":6,"i2":6,"i3":6,"i4":18,"i5":18,"i6":18,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":6,"i14":18,"i15":6,"i16":6,"i17":6,"i18":6,"i19":6,"i20":6,"i21":6,"i22":6,"i23":6,"i24":6,"i25":6,"i26":18,"i27":6,"i28":6,"i29":18,"i30":18,"i31":18,"i32":6,"i33":6,"i34":6,"i35":18,"i36":18,"i37":6,"i38":6,"i39":18,"i40":6,"i41":18,"i42":6,"i43":6,"i44":6,"i45":6,"i46":18,"i47":18,"i48":18,"i49":18,"i50":18,"i51":6,"i52":6,"i53":18};
var tabs = {65535:["t0","All Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],16:["t5","Default Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="../../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Buffer.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="moduleLabelInType">Module</span>&nbsp;<a href="../../../../module-summary.html">io.netty5.buffer</a></div>
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">io.netty5.buffer.api</a></div>
<h2 title="Interface Buffer" class="title">Interface Buffer</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Superinterfaces:</dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/AutoCloseable.html?is-external=true" title="class or interface in java.lang" class="externalLink">AutoCloseable</a></code>, <code><a href="BufferAccessor.html" title="interface in io.netty5.buffer.api">BufferAccessor</a></code>, <code><a href="Resource.html" title="interface in io.netty5.buffer.api">Resource</a>&lt;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&gt;</code></dd>
</dl>
<dl>
<dt>All Known Subinterfaces:</dt>
<dd><code><a href="CompositeBuffer.html" title="interface in io.netty5.buffer.api">CompositeBuffer</a></code></dd>
</dl>
<dl>
<dt>All Known Implementing Classes:</dt>
<dd><code><a href="internal/AdaptableBuffer.html" title="class in io.netty5.buffer.api.internal">AdaptableBuffer</a></code>, <code><a href="BufferStub.html" title="class in io.netty5.buffer.api">BufferStub</a></code>, <code><a href="adaptor/ByteBufBuffer.html" title="class in io.netty5.buffer.api.adaptor">ByteBufBuffer</a></code></dd>
</dl>
<hr>
<pre>public interface <span class="typeNameLabel">Buffer</span>
extends <a href="Resource.html" title="interface in io.netty5.buffer.api">Resource</a>&lt;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&gt;, <a href="BufferAccessor.html" title="interface in io.netty5.buffer.api">BufferAccessor</a></pre>
<div class="block">A life cycled buffer of memory, with separate reader and writer offsets.
 <p>
 A buffer is a logically sequential stretch of memory with a certain capacity, an offset for writing,
 and an offset for reading.
 Buffers may be <a href="CompositeBuffer.html" title="interface in io.netty5.buffer.api">composed</a> of multiple <a href="#countComponents()">components</a>,
 where each component is a guaranteed contiguous chunk of memory.

 <h3>Creating a buffer</h3>

 Buffers are created by <a href="BufferAllocator.html" title="interface in io.netty5.buffer.api">allocators</a>, and their <code>allocate</code> family of methods.
 A number of standard allocators exist, and are available through static methods on the <code>BufferAllocator</code>
 interface.

 <h3>Buffer life cycle</h3>

 The buffer has a life cycle, where it is allocated, used, and deallocated.
 When the buffer is initially allocated, a pairing <a href="Resource.html#close()"><code>Resource.close()</code></a> call will deallocate it.
 If a buffer is <a href="Resource.html#send()">sent</a> elsewhere, the <a href="Resource.html#close()">close</a> method on the given instance
 will become a no-op.
 The buffer can be thought of as a view onto memory, and calling <a href="Resource.html#send()"><code>Resource.send()</code></a> on the buffer will effectively close
 that view, and recreate it upon reception at its destination.

 <h3>Thread-safety</h3>

 Buffers are <strong>not</strong> thread-safe.

 <h3>Accessing data</h3>

 Data access methods fall into two classes:
 <ol>
     <li>Access that are based on, and updates, the read or write offset positions.</li>
     <ul><li>These accessor methods are typically called <code>readX</code> or <code>writeX</code>.</li></ul>
     <li>Access that take offsets as arguments, and do not update read or write offset positions.</li>
     <ul><li>These accessor methods are typically called <code>getX</code> or <code>setX</code>.</li></ul>
 </ol>

 A buffer contains two mutable offset positions: one for reading and one for writing.
 These positions use <a href="https://en.wikipedia.org/wiki/Zero-based_numbering">zero-based indexing</a>,
 such that the first byte of data in the buffer is placed at offset <code>0</code>,
 and the last byte in the buffer is at offset <a href="#capacity()"><code>capacity - 1</code></a>.
 The <a href="#readerOffset()"><code>readerOffset()</code></a> is the offset into the buffer from which the next read will take place,
 and is initially zero.
 The reader offset must always be less than or equal to the <a href="#writerOffset()"><code>writerOffset()</code></a>.
 The <a href="#writerOffset()"><code>writerOffset()</code></a> is likewise the offset into the buffer where the next write will take place.
 The writer offset is also initially zero, and must be less than or equal to the <a href="#capacity()">capacity</a>.
 <p>
 This carves the buffer into three regions, as demonstrated by this diagram:
 <pre>
      +-------------------+------------------+------------------+
      | discardable bytes |  readable bytes  |  writable bytes  |
      |                   |     (CONTENT)    |                  |
      +-------------------+------------------+------------------+
      |                   |                  |                  |
      0      <=     readerOffset  <=   writerOffset    <=    capacity
 </pre>

 <h3>Byte Order</h3>

 Buffers are always big endian, and this cannot be changed.
 Usages that need to get, set, read, or write, little-endian values will have to flip the byte order of the values
 they read and write.

 <h3 name="split">Splitting buffers</h3>

 The <a href="#split()"><code>split()</code></a> method breaks a buffer into two.
 The two buffers will share the underlying memory, but their regions will not overlap, ensuring that the memory is
 safely shared between the two.
 <p>
 Splitting a buffer is useful for when you want to hand over a region of a buffer to some other,
 perhaps unknown, piece of code, and relinquish your ownership of that buffer region in the process.
 Examples include aggregating messages into an accumulator buffer, and sending messages down the pipeline for
 further processing, as split buffer regions, once their data has been received in its entirety.

 If you instead wish to temporarily share a region of a buffer, you will have to pass offset and length along with the
 buffer, or you will have to make a copy of the region.

 <h3>Buffers as constants</h3>

 Sometimes, the same bit of data will be processed or transmitted over and over again. In such cases, it can be
 tempting to allocate and fill a buffer once, and then reuse it.
 Such reuse must be done carefully, however, to avoid a number of bugs.
 The <a href="BufferAllocator.html" title="interface in io.netty5.buffer.api"><code>BufferAllocator</code></a> has a <a href="BufferAllocator.html#constBufferSupplier(byte%5B%5D)"><code>BufferAllocator.constBufferSupplier(byte[])</code></a> method that solves this, and
 prevents these bugs from occurring.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t5" class="tableTab"><span><a href="javascript:show(16);">Default Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bytesBefore(byte)">bytesBefore</a></span>&#8203;(byte&nbsp;needle)</code></th>
<td class="colLast">
<div class="block">Get the number of <a href="#readableBytes()">readable bytes</a>, until the given <code>needle</code> is found in this
 buffer.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#bytesBefore(io.netty5.buffer.api.Buffer)">bytesBefore</a></span>&#8203;(<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;needle)</code></th>
<td class="colLast">
<div class="block">Get the number of <a href="#readableBytes()">readable bytes</a>, until the given <code>needle</code> is found in this
 buffer.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#capacity()">capacity</a></span>()</code></th>
<td class="colLast">
<div class="block">The capacity of this buffer, that is, the maximum number of bytes it can contain.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compact()">compact</a></span>()</code></th>
<td class="colLast">
<div class="block">Discards the read bytes, and moves the buffer contents to the beginning of the buffer.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#copy()">copy</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns a copy of this buffer's readable bytes.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#copy(boolean)">copy</a></span>&#8203;(boolean&nbsp;readOnly)</code></th>
<td class="colLast">
<div class="block">Returns a copy of this buffer's readable bytes, with the given read-only setting.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#copy(int,int)">copy</a></span>&#8203;(int&nbsp;offset,
    int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Returns a copy of the given region of this buffer.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#copy(int,int,boolean)">copy</a></span>&#8203;(int&nbsp;offset,
    int&nbsp;length,
    boolean&nbsp;readOnly)</code></th>
<td class="colLast">
<div class="block">Returns a copy of the given region of this buffer.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#copyInto(int,byte%5B%5D,int,int)">copyInto</a></span>&#8203;(int&nbsp;srcPos,
        byte[]&nbsp;dest,
        int&nbsp;destPos,
        int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Copies the given length of data from this buffer into the given destination array, beginning at the given source
 position in this buffer, and the given destination position in the destination array.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#copyInto(int,io.netty5.buffer.api.Buffer,int,int)">copyInto</a></span>&#8203;(int&nbsp;srcPos,
        <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;dest,
        int&nbsp;destPos,
        int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Copies the given length of data from this buffer into the given destination buffer, beginning at the given
 source position in this buffer, and the given destination position in the destination buffer.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#copyInto(int,java.nio.ByteBuffer,int,int)">copyInto</a></span>&#8203;(int&nbsp;srcPos,
        <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink">ByteBuffer</a>&nbsp;dest,
        int&nbsp;destPos,
        int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Copies the given length of data from this buffer into the given destination byte buffer, beginning at the given
 source position in this buffer, and the given destination position in the destination byte buffer.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countComponents()">countComponents</a></span>()</code></th>
<td class="colLast">
<div class="block">Get the number of "components" in this buffer.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countReadableComponents()">countReadableComponents</a></span>()</code></th>
<td class="colLast">
<div class="block">Get the number of "components" in this buffer, that are readable.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#countWritableComponents()">countWritableComponents</a></span>()</code></th>
<td class="colLast">
<div class="block">Get the number of "components" in this buffer, that are writable.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ensureWritable(int)">ensureWritable</a></span>&#8203;(int&nbsp;size)</code></th>
<td class="colLast">
<div class="block">Ensures that this buffer has at least the given number of bytes of
 <a href="#writableBytes()">available space for writing</a>.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ensureWritable(int,int,boolean)">ensureWritable</a></span>&#8203;(int&nbsp;size,
              int&nbsp;minimumGrowth,
              boolean&nbsp;allowCompaction)</code></th>
<td class="colLast">
<div class="block">Ensures that this buffer has at least the given number of bytes of
 <a href="#writableBytes()">available space for writing</a>.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fill(byte)">fill</a></span>&#8203;(byte&nbsp;value)</code></th>
<td class="colLast">
<div class="block">Fills the buffer with the given byte value.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>&lt;T extends <a href="ReadableComponent.html" title="interface in io.netty5.buffer.api">ReadableComponent</a> &amp; <a href="ComponentIterator.Next.html" title="interface in io.netty5.buffer.api">ComponentIterator.Next</a>&gt;<br><a href="ComponentIterator.html" title="interface in io.netty5.buffer.api">ComponentIterator</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#forEachReadable()">forEachReadable</a></span>()</code></th>
<td class="colLast">
<div class="block">Create a <a href="ComponentIterator.html" title="interface in io.netty5.buffer.api">component iterator</a> for all readable components in this buffer.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>&lt;E extends <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Exception.html?is-external=true" title="class or interface in java.lang" class="externalLink">Exception</a>&gt;<br>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#forEachReadable(int,io.netty5.buffer.api.ReadableComponentProcessor)">forEachReadable</a></span>&#8203;(int&nbsp;initialIndex,
               <a href="ReadableComponentProcessor.html" title="interface in io.netty5.buffer.api">ReadableComponentProcessor</a>&lt;E&gt;&nbsp;processor)</code></th>
<td class="colLast">
<div class="block">Processes all readable components of this buffer, and return the number of components processed.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>&lt;T extends <a href="WritableComponent.html" title="interface in io.netty5.buffer.api">WritableComponent</a> &amp; <a href="ComponentIterator.Next.html" title="interface in io.netty5.buffer.api">ComponentIterator.Next</a>&gt;<br><a href="ComponentIterator.html" title="interface in io.netty5.buffer.api">ComponentIterator</a>&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#forEachWritable()">forEachWritable</a></span>()</code></th>
<td class="colLast">
<div class="block">Create a <a href="ComponentIterator.html" title="interface in io.netty5.buffer.api">component iterator</a> for all writable components in this buffer.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>&lt;E extends <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Exception.html?is-external=true" title="class or interface in java.lang" class="externalLink">Exception</a>&gt;<br>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#forEachWritable(int,io.netty5.buffer.api.WritableComponentProcessor)">forEachWritable</a></span>&#8203;(int&nbsp;initialIndex,
               <a href="WritableComponentProcessor.html" title="interface in io.netty5.buffer.api">WritableComponentProcessor</a>&lt;E&gt;&nbsp;processor)</code></th>
<td class="colLast">
<div class="block">Process all writable components of this buffer, and return the number of components processed.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#implicitCapacityLimit(int)">implicitCapacityLimit</a></span>&#8203;(int&nbsp;limit)</code></th>
<td class="colLast">
<div class="block">Set an upper limit to the implicit capacity growth.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isDirect()">isDirect</a></span>()</code></th>
<td class="colLast">
<div class="block">Queries if this buffer is backed by native memory, or not.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeReadOnly()">makeReadOnly</a></span>()</code></th>
<td class="colLast">
<div class="block">Makes this buffer read-only.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code><a href="ByteCursor.html" title="interface in io.netty5.buffer.api">ByteCursor</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#openCursor()">openCursor</a></span>()</code></th>
<td class="colLast">
<div class="block">Opens a cursor to iterate the readable bytes of this buffer.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code><a href="ByteCursor.html" title="interface in io.netty5.buffer.api">ByteCursor</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#openCursor(int,int)">openCursor</a></span>&#8203;(int&nbsp;fromOffset,
          int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Opens a cursor to iterate the given number bytes of this buffer, starting at the given offset.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code>default <a href="ByteCursor.html" title="interface in io.netty5.buffer.api">ByteCursor</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#openReverseCursor()">openReverseCursor</a></span>()</code></th>
<td class="colLast">
<div class="block">Opens a cursor to iterate the readable bytes of this buffer, in reverse.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code><a href="ByteCursor.html" title="interface in io.netty5.buffer.api">ByteCursor</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#openReverseCursor(int,int)">openReverseCursor</a></span>&#8203;(int&nbsp;fromOffset,
                 int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Opens a cursor to iterate the given number bytes of this buffer, in reverse, starting at the given offset.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#readableBytes()">readableBytes</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the number of readable bytes which is equal to <code>(writerOffset() - readerOffset())</code>.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#readBytes(byte%5B%5D,int,int)">readBytes</a></span>&#8203;(byte[]&nbsp;destination,
         int&nbsp;destPos,
         int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Read from this buffer, into the destination array, the given number of bytes.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#readBytes(java.nio.ByteBuffer)">readBytes</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink">ByteBuffer</a>&nbsp;destination)</code></th>
<td class="colLast">
<div class="block">Read from this buffer, into the destination <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a>
 This updates the <a href="#readerOffset()">read offset</a> of this buffer and also the position of
 the destination <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a>.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>default <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/CharSequence.html?is-external=true" title="class or interface in java.lang" class="externalLink">CharSequence</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#readCharSequence(int,java.nio.charset.Charset)">readCharSequence</a></span>&#8203;(int&nbsp;length,
                <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/Charset.html?is-external=true" title="class or interface in java.nio.charset" class="externalLink">Charset</a>&nbsp;charset)</code></th>
<td class="colLast">
<div class="block">Reads a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/CharSequence.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>CharSequence</code></a> of the passed <code>length</code> using the passed <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/Charset.html?is-external=true" title="class or interface in java.nio.charset" class="externalLink"><code>Charset</code></a>.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#readerOffset()">readerOffset</a></span>()</code></th>
<td class="colLast">
<div class="block">Get the current reader offset.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#readerOffset(int)">readerOffset</a></span>&#8203;(int&nbsp;offset)</code></th>
<td class="colLast">
<div class="block">Set the reader offset.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#readOnly()">readOnly</a></span>()</code></th>
<td class="colLast">
<div class="block">Queries if this buffer is read-only or not.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#readSplit(int)">readSplit</a></span>&#8203;(int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Splits the buffer into two, at <code>length</code> number of bytes from the current
 <a href="#readerOffset()">readerOffset()</a> reader offset} position.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#resetOffsets()">resetOffsets</a></span>()</code></th>
<td class="colLast">
<div class="block">Resets the <a href="#readerOffset()">read offset</a> and the <a href="#writerOffset()">write offset</a> on this
 buffer to zero, and return this buffer.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#skipReadable(int)">skipReadable</a></span>&#8203;(int&nbsp;delta)</code></th>
<td class="colLast">
<div class="block">Move the reader offset forward by the given delta.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#skipWritable(int)">skipWritable</a></span>&#8203;(int&nbsp;delta)</code></th>
<td class="colLast">
<div class="block">Move the writer offset to ahead by the given delta.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#split()">split</a></span>()</code></th>
<td class="colLast">
<div class="block">Splits the buffer into two, at the <a href="#writerOffset()">write offset</a> position.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#split(int)">split</a></span>&#8203;(int&nbsp;splitOffset)</code></th>
<td class="colLast">
<div class="block">Splits the buffer into two, at the given <code>splitOffset</code>.</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>default <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#toString(java.nio.charset.Charset)">toString</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/Charset.html?is-external=true" title="class or interface in java.nio.charset" class="externalLink">Charset</a>&nbsp;charset)</code></th>
<td class="colLast">
<div class="block">Decodes this buffer's readable bytes into a string with the specified <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/Charset.html?is-external=true" title="class or interface in java.nio.charset" class="externalLink">Charset</a>.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#transferFrom(java.nio.channels.FileChannel,long,int)">transferFrom</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/FileChannel.html?is-external=true" title="class or interface in java.nio.channels" class="externalLink">FileChannel</a>&nbsp;channel,
            long&nbsp;position,
            int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Read from the given channel starting from the given position and write to this buffer.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#transferFrom(java.nio.channels.ReadableByteChannel,int)">transferFrom</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/ReadableByteChannel.html?is-external=true" title="class or interface in java.nio.channels" class="externalLink">ReadableByteChannel</a>&nbsp;channel,
            int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Read from the given channel and write to this buffer.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#transferTo(java.nio.channels.WritableByteChannel,int)">transferTo</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/WritableByteChannel.html?is-external=true" title="class or interface in java.nio.channels" class="externalLink">WritableByteChannel</a>&nbsp;channel,
          int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Read from this buffer and write to the given channel.</div>
</td>
</tr>
<tr id="i45" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writableBytes()">writableBytes</a></span>()</code></th>
<td class="colLast">
<div class="block">Returns the number of writable bytes which is equal to <code>(capacity() - writerOffset())</code>.</div>
</td>
</tr>
<tr id="i46" class="altColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writeBytes(byte%5B%5D)">writeBytes</a></span>&#8203;(byte[]&nbsp;source)</code></th>
<td class="colLast">
<div class="block">Writes into this buffer, all the bytes from the given byte array.</div>
</td>
</tr>
<tr id="i47" class="rowColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writeBytes(byte%5B%5D,int,int)">writeBytes</a></span>&#8203;(byte[]&nbsp;source,
          int&nbsp;srcPos,
          int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Writes into this buffer, the given number of bytes from the byte array.</div>
</td>
</tr>
<tr id="i48" class="altColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writeBytes(io.netty5.buffer.api.Buffer)">writeBytes</a></span>&#8203;(<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;source)</code></th>
<td class="colLast">
<div class="block">Writes into this buffer, all the readable bytes from the given buffer.</div>
</td>
</tr>
<tr id="i49" class="rowColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writeBytes(java.nio.ByteBuffer)">writeBytes</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink">ByteBuffer</a>&nbsp;source)</code></th>
<td class="colLast">
<div class="block">Writes into this buffer from the source <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a>.</div>
</td>
</tr>
<tr id="i50" class="altColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writeCharSequence(java.lang.CharSequence,java.nio.charset.Charset)">writeCharSequence</a></span>&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/CharSequence.html?is-external=true" title="class or interface in java.lang" class="externalLink">CharSequence</a>&nbsp;source,
                 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/Charset.html?is-external=true" title="class or interface in java.nio.charset" class="externalLink">Charset</a>&nbsp;charset)</code></th>
<td class="colLast">
<div class="block">Writes into this buffer, all the bytes from the given <code>source</code> using the passed <code>charset</code>.</div>
</td>
</tr>
<tr id="i51" class="rowColor">
<td class="colFirst"><code>int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writerOffset()">writerOffset</a></span>()</code></th>
<td class="colLast">
<div class="block">Get the current writer offset.</div>
</td>
</tr>
<tr id="i52" class="altColor">
<td class="colFirst"><code><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writerOffset(int)">writerOffset</a></span>&#8203;(int&nbsp;offset)</code></th>
<td class="colLast">
<div class="block">Set the writer offset.</div>
</td>
</tr>
<tr id="i53" class="rowColor">
<td class="colFirst"><code>default <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#writeSplit(int)">writeSplit</a></span>&#8203;(int&nbsp;length)</code></th>
<td class="colLast">
<div class="block">Splits the buffer into two, at <code>length</code> number of bytes from the current
 <a href="#writerOffset()">writerOffset()</a> writer offset} position.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.io.netty5.buffer.api.BufferAccessor">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;io.netty5.buffer.api.<a href="BufferAccessor.html" title="interface in io.netty5.buffer.api">BufferAccessor</a></h3>
<code><a href="BufferAccessor.html#getBoolean(int)">getBoolean</a>, <a href="BufferAccessor.html#getByte(int)">getByte</a>, <a href="BufferAccessor.html#getChar(int)">getChar</a>, <a href="BufferAccessor.html#getDouble(int)">getDouble</a>, <a href="BufferAccessor.html#getFloat(int)">getFloat</a>, <a href="BufferAccessor.html#getInt(int)">getInt</a>, <a href="BufferAccessor.html#getLong(int)">getLong</a>, <a href="BufferAccessor.html#getMedium(int)">getMedium</a>, <a href="BufferAccessor.html#getShort(int)">getShort</a>, <a href="BufferAccessor.html#getUnsignedByte(int)">getUnsignedByte</a>, <a href="BufferAccessor.html#getUnsignedInt(int)">getUnsignedInt</a>, <a href="BufferAccessor.html#getUnsignedMedium(int)">getUnsignedMedium</a>, <a href="BufferAccessor.html#getUnsignedShort(int)">getUnsignedShort</a>, <a href="BufferAccessor.html#readBoolean()">readBoolean</a>, <a href="BufferAccessor.html#readByte()">readByte</a>, <a href="BufferAccessor.html#readChar()">readChar</a>, <a href="BufferAccessor.html#readDouble()">readDouble</a>, <a href="BufferAccessor.html#readFloat()">readFloat</a>, <a href="BufferAccessor.html#readInt()">readInt</a>, <a href="BufferAccessor.html#readLong()">readLong</a>, <a href="BufferAccessor.html#readMedium()">readMedium</a>, <a href="BufferAccessor.html#readShort()">readShort</a>, <a href="BufferAccessor.html#readUnsignedByte()">readUnsignedByte</a>, <a href="BufferAccessor.html#readUnsignedInt()">readUnsignedInt</a>, <a href="BufferAccessor.html#readUnsignedMedium()">readUnsignedMedium</a>, <a href="BufferAccessor.html#readUnsignedShort()">readUnsignedShort</a>, <a href="BufferAccessor.html#setBoolean(int,boolean)">setBoolean</a>, <a href="BufferAccessor.html#setByte(int,byte)">setByte</a>, <a href="BufferAccessor.html#setChar(int,char)">setChar</a>, <a href="BufferAccessor.html#setDouble(int,double)">setDouble</a>, <a href="BufferAccessor.html#setFloat(int,float)">setFloat</a>, <a href="BufferAccessor.html#setInt(int,int)">setInt</a>, <a href="BufferAccessor.html#setLong(int,long)">setLong</a>, <a href="BufferAccessor.html#setMedium(int,int)">setMedium</a>, <a href="BufferAccessor.html#setShort(int,short)">setShort</a>, <a href="BufferAccessor.html#setUnsignedByte(int,int)">setUnsignedByte</a>, <a href="BufferAccessor.html#setUnsignedInt(int,long)">setUnsignedInt</a>, <a href="BufferAccessor.html#setUnsignedMedium(int,int)">setUnsignedMedium</a>, <a href="BufferAccessor.html#setUnsignedShort(int,int)">setUnsignedShort</a>, <a href="BufferAccessor.html#writeBoolean(boolean)">writeBoolean</a>, <a href="BufferAccessor.html#writeByte(byte)">writeByte</a>, <a href="BufferAccessor.html#writeChar(char)">writeChar</a>, <a href="BufferAccessor.html#writeDouble(double)">writeDouble</a>, <a href="BufferAccessor.html#writeFloat(float)">writeFloat</a>, <a href="BufferAccessor.html#writeInt(int)">writeInt</a>, <a href="BufferAccessor.html#writeLong(long)">writeLong</a>, <a href="BufferAccessor.html#writeMedium(int)">writeMedium</a>, <a href="BufferAccessor.html#writeShort(short)">writeShort</a>, <a href="BufferAccessor.html#writeUnsignedByte(int)">writeUnsignedByte</a>, <a href="BufferAccessor.html#writeUnsignedInt(long)">writeUnsignedInt</a>, <a href="BufferAccessor.html#writeUnsignedMedium(int)">writeUnsignedMedium</a>, <a href="BufferAccessor.html#writeUnsignedShort(int)">writeUnsignedShort</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.io.netty5.buffer.api.Resource">
<!--   -->
</a>
<h3>Methods inherited from interface&nbsp;io.netty5.buffer.api.<a href="Resource.html" title="interface in io.netty5.buffer.api">Resource</a></h3>
<code><a href="Resource.html#close()">close</a>, <a href="Resource.html#isAccessible()">isAccessible</a>, <a href="Resource.html#send()">send</a>, <a href="Resource.html#touch(java.lang.Object)">touch</a></code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="capacity()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>capacity</h4>
<pre class="methodSignature">int&nbsp;capacity()</pre>
<div class="block">The capacity of this buffer, that is, the maximum number of bytes it can contain.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The capacity in bytes.</dd>
</dl>
</li>
</ul>
<a id="readerOffset()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readerOffset</h4>
<pre class="methodSignature">int&nbsp;readerOffset()</pre>
<div class="block">Get the current reader offset. The next read will happen from this byte offset into the buffer.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The current reader offset.</dd>
</dl>
</li>
</ul>
<a id="skipReadable(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skipReadable</h4>
<pre class="methodSignature"><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;skipReadable&#8203;(int&nbsp;delta)</pre>
<div class="block">Move the reader offset forward by the given delta.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>delta</code> - to accumulate.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer instance.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IndexOutOfBoundsException</a></code> - if the new reader offset is greater than the current
 <a href="#writerOffset()"><code>writerOffset()</code></a>.</dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalArgumentException</a></code> - if the given delta is negative.</dd>
<dd><code><a href="BufferClosedException.html" title="class in io.netty5.buffer.api">BufferClosedException</a></code> - if this buffer is closed.</dd>
</dl>
</li>
</ul>
<a id="readerOffset(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readerOffset</h4>
<pre class="methodSignature"><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;readerOffset&#8203;(int&nbsp;offset)</pre>
<div class="block">Set the reader offset. Make the next read happen from the given offset into the buffer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>offset</code> - The reader offset to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This Buffer.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IndexOutOfBoundsException</a></code> - if the specified <code>offset</code> is less than zero or greater than the current
                                   <a href="#writerOffset()"><code>writerOffset()</code></a>.</dd>
<dd><code><a href="BufferClosedException.html" title="class in io.netty5.buffer.api">BufferClosedException</a></code> - if this buffer is closed.</dd>
</dl>
</li>
</ul>
<a id="writerOffset()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writerOffset</h4>
<pre class="methodSignature">int&nbsp;writerOffset()</pre>
<div class="block">Get the current writer offset. The next write will happen at this byte offset into the buffer.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The current writer offset.</dd>
</dl>
</li>
</ul>
<a id="skipWritable(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>skipWritable</h4>
<pre class="methodSignature"><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;skipWritable&#8203;(int&nbsp;delta)</pre>
<div class="block">Move the writer offset to ahead by the given delta.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>delta</code> - to accumulate.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer instance.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IndexOutOfBoundsException</a></code> - if the new writer offset is greater than <a href="#capacity()"><code>capacity()</code></a>.</dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalArgumentException</a></code> - if the given delta is negative.</dd>
<dd><code><a href="BufferClosedException.html" title="class in io.netty5.buffer.api">BufferClosedException</a></code> - if this buffer is closed.</dd>
<dd><code><a href="BufferReadOnlyException.html" title="class in io.netty5.buffer.api">BufferReadOnlyException</a></code> - if this buffer is <a href="#readOnly()">read-only</a>.</dd>
</dl>
</li>
</ul>
<a id="writerOffset(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writerOffset</h4>
<pre class="methodSignature"><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;writerOffset&#8203;(int&nbsp;offset)</pre>
<div class="block">Set the writer offset. Make the next write happen at the given offset.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>offset</code> - The writer offset to set.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This Buffer.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IndexOutOfBoundsException</a></code> - if the specified <code>offset</code> is less than the current
 <a href="#readerOffset()"><code>readerOffset()</code></a> or greater than <a href="#capacity()"><code>capacity()</code></a>.</dd>
<dd><code><a href="BufferClosedException.html" title="class in io.netty5.buffer.api">BufferClosedException</a></code> - if this buffer is closed.</dd>
<dd><code><a href="BufferReadOnlyException.html" title="class in io.netty5.buffer.api">BufferReadOnlyException</a></code> - if this buffer is <a href="#readOnly()">read-only</a>.</dd>
</dl>
</li>
</ul>
<a id="readableBytes()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readableBytes</h4>
<pre class="methodSignature">int&nbsp;readableBytes()</pre>
<div class="block">Returns the number of readable bytes which is equal to <code>(writerOffset() - readerOffset())</code>.</div>
</li>
</ul>
<a id="writableBytes()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writableBytes</h4>
<pre class="methodSignature">int&nbsp;writableBytes()</pre>
<div class="block">Returns the number of writable bytes which is equal to <code>(capacity() - writerOffset())</code>.</div>
</li>
</ul>
<a id="fill(byte)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fill</h4>
<pre class="methodSignature"><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;fill&#8203;(byte&nbsp;value)</pre>
<div class="block">Fills the buffer with the given byte value. This method does not respect the <a href="#readerOffset()"><code>readerOffset()</code></a> or <a href="#writerOffset()"><code>writerOffset()</code></a>, but copies the full capacity of the buffer. The <a href="#readerOffset()"><code>readerOffset()</code></a> and <a href="#writerOffset()"><code>writerOffset()</code></a> are not modified.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>value</code> - The byte value to write at every offset in the buffer.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This Buffer.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="BufferReadOnlyException.html" title="class in io.netty5.buffer.api">BufferReadOnlyException</a></code> - if this buffer is <a href="#readOnly()">read-only</a>.</dd>
</dl>
</li>
</ul>
<a id="makeReadOnly()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeReadOnly</h4>
<pre class="methodSignature"><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;makeReadOnly()</pre>
<div class="block">Makes this buffer read-only. This is irreversible.
 This operation is also idempotent, so calling this method multiple times on the same buffer makes no difference.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer instance.</dd>
</dl>
</li>
</ul>
<a id="readOnly()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readOnly</h4>
<pre class="methodSignature">boolean&nbsp;readOnly()</pre>
<div class="block">Queries if this buffer is read-only or not.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if this buffer is read-only, <code>false</code> otherwise.</dd>
</dl>
</li>
</ul>
<a id="isDirect()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isDirect</h4>
<pre class="methodSignature">boolean&nbsp;isDirect()</pre>
<div class="block">Queries if this buffer is backed by native memory, or not.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>true</code> if this buffer is backed by native, off-heap, memory. Otherwise, <code>false</code>, if this
 buffer is backed by on-heap memory.</dd>
</dl>
</li>
</ul>
<a id="implicitCapacityLimit(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>implicitCapacityLimit</h4>
<pre class="methodSignature"><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;implicitCapacityLimit&#8203;(int&nbsp;limit)</pre>
<div class="block">Set an upper limit to the implicit capacity growth. Buffer <code>write*</code> methods may implicitly grow the buffer
 capacity instead of throwing a bounds check exception. The implicit capacity limit restricts this growth so the
 buffer capacity does not automatically grow beyond the given limit. When the limit is reached, and there is no
 more writable space left, then the <code>write*</code> methods will start throwing exceptions.
 <p>
 The default limit is the maximum buffer size.
 <p>
 The limit is carried through <a href="Resource.html#send()"><code>Resource.send()</code></a> calls, but the buffer instances returned from the various
 <code>split</code> and <code>copy</code> methods will have the default limit set.
 <p>
 The limit is not impacted by calls to <code>split</code> methods on this buffer. In other words, even though
 <code>split</code> methods reduce the capacity of this buffer, the set limit, if any, remains the same.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>limit</code> - The maximum size this buffers capacity will implicitly grow to via <code>write*</code> methods.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer instance.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IndexOutOfBoundsException</a></code> - if the limit is negative, greater than the maximum buffer size, or if the
                                   <a href="#capacity()">capacity</a> is already greater than the given limit.</dd>
</dl>
</li>
</ul>
<a id="copyInto(int,byte[],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyInto</h4>
<pre class="methodSignature">void&nbsp;copyInto&#8203;(int&nbsp;srcPos,
              byte[]&nbsp;dest,
              int&nbsp;destPos,
              int&nbsp;length)</pre>
<div class="block">Copies the given length of data from this buffer into the given destination array, beginning at the given source
 position in this buffer, and the given destination position in the destination array.
 <p>
 This method does not read or modify the <a href="#writerOffset()">write offset</a> or the
 <a href="#readerOffset()">read offset</a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>srcPos</code> - The byte offset into this buffer from where the copying should start; the byte at this offset in
              this buffer will be copied to the <code>destPos</code> index in the <code>dest</code> array.</dd>
<dd><code>dest</code> - The destination byte array.</dd>
<dd><code>destPos</code> - The index into the <code>dest</code> array from where the copying should start.</dd>
<dd><code>length</code> - The number of bytes to copy.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html?is-external=true" title="class or interface in java.lang" class="externalLink">NullPointerException</a></code> - if the destination array is null.</dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IndexOutOfBoundsException</a></code> - if the source or destination positions, or the length, are negative,
 or if the resulting end positions reaches beyond the end of either this buffer, or the destination array.</dd>
<dd><code><a href="BufferClosedException.html" title="class in io.netty5.buffer.api">BufferClosedException</a></code> - if this buffer is closed.</dd>
</dl>
</li>
</ul>
<a id="copyInto(int,java.nio.ByteBuffer,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyInto</h4>
<pre class="methodSignature">void&nbsp;copyInto&#8203;(int&nbsp;srcPos,
              <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink">ByteBuffer</a>&nbsp;dest,
              int&nbsp;destPos,
              int&nbsp;length)</pre>
<div class="block">Copies the given length of data from this buffer into the given destination byte buffer, beginning at the given
 source position in this buffer, and the given destination position in the destination byte buffer.
 <p>
 This method does not read or modify the <a href="#writerOffset()">write offset</a> or the
 <a href="#readerOffset()">read offset</a>, nor is the position of the destination buffer changed.
 <p>
 The position and limit of the destination byte buffer are also ignored, and do not influence <code>destPos</code>
 or <code>length</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>srcPos</code> - The byte offset into this buffer from where the copying should start; the byte at this offset in
              this buffer will be copied to the <code>destPos</code> index in the <code>dest</code> array.</dd>
<dd><code>dest</code> - The destination byte buffer.</dd>
<dd><code>destPos</code> - The index into the <code>dest</code> array from where the copying should start.</dd>
<dd><code>length</code> - The number of bytes to copy.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html?is-external=true" title="class or interface in java.lang" class="externalLink">NullPointerException</a></code> - if the destination buffer is null.</dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IndexOutOfBoundsException</a></code> - if the source or destination positions, or the length, are negative,
 or if the resulting end positions reaches beyond the end of either this buffer, or the destination array.</dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ReadOnlyBufferException.html?is-external=true" title="class or interface in java.nio" class="externalLink">ReadOnlyBufferException</a></code> - if the destination buffer is read-only.</dd>
<dd><code><a href="BufferClosedException.html" title="class in io.netty5.buffer.api">BufferClosedException</a></code> - if this buffer is closed.</dd>
</dl>
</li>
</ul>
<a id="copyInto(int,io.netty5.buffer.api.Buffer,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copyInto</h4>
<pre class="methodSignature">void&nbsp;copyInto&#8203;(int&nbsp;srcPos,
              <a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;dest,
              int&nbsp;destPos,
              int&nbsp;length)</pre>
<div class="block">Copies the given length of data from this buffer into the given destination buffer, beginning at the given
 source position in this buffer, and the given destination position in the destination buffer.
 <p>
 This method does not read or modify the <a href="#writerOffset()">write offset</a> or the
 <a href="#readerOffset()">read offset</a> on this buffer, nor on the destination buffer.
 <p>
 The read and write offsets of the destination buffer are also ignored, and do not influence <code>destPos</code>
 or <code>length</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>srcPos</code> - The byte offset into this buffer from where the copying should start; the byte at this offset in
              this buffer will be copied to the <code>destPos</code> index in the <code>dest</code> array.</dd>
<dd><code>dest</code> - The destination buffer.</dd>
<dd><code>destPos</code> - The index into the <code>dest</code> array from where the copying should start.</dd>
<dd><code>length</code> - The number of bytes to copy.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html?is-external=true" title="class or interface in java.lang" class="externalLink">NullPointerException</a></code> - if the destination buffer is null.</dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IndexOutOfBoundsException</a></code> - if the source or destination positions, or the length, are negative,
 or if the resulting end positions reaches beyond the end of either this buffer, or the destination array.</dd>
<dd><code><a href="BufferReadOnlyException.html" title="class in io.netty5.buffer.api">BufferReadOnlyException</a></code> - if the destination buffer is read-only.</dd>
<dd><code><a href="BufferClosedException.html" title="class in io.netty5.buffer.api">BufferClosedException</a></code> - if this or the destination buffer is closed.</dd>
</dl>
</li>
</ul>
<a id="transferTo(java.nio.channels.WritableByteChannel,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transferTo</h4>
<pre class="methodSignature">int&nbsp;transferTo&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/WritableByteChannel.html?is-external=true" title="class or interface in java.nio.channels" class="externalLink">WritableByteChannel</a>&nbsp;channel,
               int&nbsp;length)
        throws <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/IOException.html?is-external=true" title="class or interface in java.io" class="externalLink">IOException</a></pre>
<div class="block">Read from this buffer and write to the given channel.
 The number of bytes actually written to the channel are returned.
 No more than the given <code>length</code> of bytes, or the number of <a href="#readableBytes()">readable bytes</a>,
 will be written to the channel, whichever is smaller.
 If the channel has a position, then it will be advanced by the number of bytes written.
 The <a href="#readerOffset()">reader-offset</a> of this buffer will likewise be advanced by the number of bytes
 written.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channel</code> - The channel to write to.</dd>
<dd><code>length</code> - The maximum number of bytes to write.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The actual number of bytes written, possibly zero.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/IOException.html?is-external=true" title="class or interface in java.io" class="externalLink">IOException</a></code> - If the write-operation on the channel failed for some reason.</dd>
</dl>
</li>
</ul>
<a id="transferFrom(java.nio.channels.FileChannel,long,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transferFrom</h4>
<pre class="methodSignature">int&nbsp;transferFrom&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/FileChannel.html?is-external=true" title="class or interface in java.nio.channels" class="externalLink">FileChannel</a>&nbsp;channel,
                 long&nbsp;position,
                 int&nbsp;length)
          throws <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/IOException.html?is-external=true" title="class or interface in java.io" class="externalLink">IOException</a></pre>
<div class="block">Read from the given channel starting from the given position and write to this buffer.
 The number of bytes actually read from the channel are returned, or -1 is returned if the channel has reached
 the end-of-stream.
 No more than the given <code>length</code> of bytes, or the number of <a href="#writableBytes()">writable bytes</a>,
 will be read from the channel, whichever is smaller.
 The channel's position is not modified.
 The <a href="#writerOffset()">writer-offset</a> of this buffer will likewise be advanced by the number of bytes
 read.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channel</code> - The channel to read from.</dd>
<dd><code>position</code> - The file position.</dd>
<dd><code>length</code> - The maximum number of bytes to read.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The actual number of bytes read, possibly zero, or -1 if the end-of-stream has been reached.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/IOException.html?is-external=true" title="class or interface in java.io" class="externalLink">IOException</a></code> - If the read-operation on the channel failed for some reason.</dd>
</dl>
</li>
</ul>
<a id="transferFrom(java.nio.channels.ReadableByteChannel,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>transferFrom</h4>
<pre class="methodSignature">int&nbsp;transferFrom&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/channels/ReadableByteChannel.html?is-external=true" title="class or interface in java.nio.channels" class="externalLink">ReadableByteChannel</a>&nbsp;channel,
                 int&nbsp;length)
          throws <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/IOException.html?is-external=true" title="class or interface in java.io" class="externalLink">IOException</a></pre>
<div class="block">Read from the given channel and write to this buffer.
 The number of bytes actually read from the channel are returned, or -1 is returned if the channel has reached
 the end-of-stream.
 No more than the given <code>length</code> of bytes, or the number of <a href="#writableBytes()">writable bytes</a>,
 will be read from the channel, whichever is smaller.
 If the channel has a position, then it will be advanced by the number of bytes read.
 The <a href="#writerOffset()">writer-offset</a> of this buffer will likewise be advanced by the number of bytes
 read.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>channel</code> - The channel to read from.</dd>
<dd><code>length</code> - The maximum number of bytes to read.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The actual number of bytes read, possibly zero, or -1 if the end-of-stream has been reached.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/IOException.html?is-external=true" title="class or interface in java.io" class="externalLink">IOException</a></code> - If the read-operation on the channel failed for some reason.</dd>
</dl>
</li>
</ul>
<a id="writeCharSequence(java.lang.CharSequence,java.nio.charset.Charset)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeCharSequence</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;writeCharSequence&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/CharSequence.html?is-external=true" title="class or interface in java.lang" class="externalLink">CharSequence</a>&nbsp;source,
                                 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/Charset.html?is-external=true" title="class or interface in java.nio.charset" class="externalLink">Charset</a>&nbsp;charset)</pre>
<div class="block">Writes into this buffer, all the bytes from the given <code>source</code> using the passed <code>charset</code>.
 This updates the <a href="#writerOffset()">write offset</a> of this buffer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/CharSequence.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>CharSequence</code></a> to read from.</dd>
<dd><code>charset</code> - <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/Charset.html?is-external=true" title="class or interface in java.nio.charset" class="externalLink"><code>Charset</code></a> to use for writing.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer.</dd>
</dl>
</li>
</ul>
<a id="readCharSequence(int,java.nio.charset.Charset)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readCharSequence</h4>
<pre class="methodSignature">default&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/CharSequence.html?is-external=true" title="class or interface in java.lang" class="externalLink">CharSequence</a>&nbsp;readCharSequence&#8203;(int&nbsp;length,
                                      <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/Charset.html?is-external=true" title="class or interface in java.nio.charset" class="externalLink">Charset</a>&nbsp;charset)</pre>
<div class="block">Reads a <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/CharSequence.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>CharSequence</code></a> of the passed <code>length</code> using the passed <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/Charset.html?is-external=true" title="class or interface in java.nio.charset" class="externalLink"><code>Charset</code></a>.
 This updates the <a href="#readerOffset()">readerOffset()</a> reader offset} of this buffer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>length</code> - of <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/CharSequence.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>CharSequence</code></a> to read.</dd>
<dd><code>charset</code> - of the bytes to be read.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/CharSequence.html?is-external=true" title="class or interface in java.lang" class="externalLink"><code>CharSequence</code></a> read from this buffer.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IndexOutOfBoundsException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IndexOutOfBoundsException</a></code> - if the passed <code>length</code> is more than the <a href="#readableBytes()">readableBytes()</a> of
 this buffer.</dd>
</dl>
</li>
</ul>
<a id="writeBytes(io.netty5.buffer.api.Buffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeBytes</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;writeBytes&#8203;(<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;source)</pre>
<div class="block">Writes into this buffer, all the readable bytes from the given buffer.
 This updates the <a href="#writerOffset()">write offset</a> of this buffer, and the
 <a href="#readerOffset()">reader offset</a> of the given buffer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - The buffer to read from.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/NullPointerException.html?is-external=true" title="class or interface in java.lang" class="externalLink">NullPointerException</a></code> - If the source buffer is <code>null</code>.</dd>
</dl>
</li>
</ul>
<a id="writeBytes(byte[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeBytes</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;writeBytes&#8203;(byte[]&nbsp;source)</pre>
<div class="block">Writes into this buffer, all the bytes from the given byte array.
 This updates the <a href="#writerOffset()">write offset</a> of this buffer by the length of the array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - The byte array to read from.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer.</dd>
</dl>
</li>
</ul>
<a id="writeBytes(byte[],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeBytes</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;writeBytes&#8203;(byte[]&nbsp;source,
                          int&nbsp;srcPos,
                          int&nbsp;length)</pre>
<div class="block">Writes into this buffer, the given number of bytes from the byte array.
 This updates the <a href="#writerOffset()">write offset</a> of this buffer by the length argument.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - The byte array to read from.</dd>
<dd><code>srcPos</code> - Position in the <code>source</code> from where bytes should be written to this buffer.</dd>
<dd><code>length</code> - The number of bytes to copy.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer.</dd>
</dl>
</li>
</ul>
<a id="writeBytes(java.nio.ByteBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeBytes</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;writeBytes&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink">ByteBuffer</a>&nbsp;source)</pre>
<div class="block">Writes into this buffer from the source <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a>.
 This updates the <a href="#writerOffset()">write offset</a> of this buffer and also the position of
 the source <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a>.
 <p>
 Note: the behaviour is undefined if the given <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a> is an alias for the memory in this buffer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - The <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a> to read from.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer.</dd>
</dl>
</li>
</ul>
<a id="readBytes(java.nio.ByteBuffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readBytes</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;readBytes&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink">ByteBuffer</a>&nbsp;destination)</pre>
<div class="block">Read from this buffer, into the destination <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a>
 This updates the <a href="#readerOffset()">read offset</a> of this buffer and also the position of
 the destination <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a>.
 <p>
 Note: the behaviour is undefined if the given <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a> is an alias for the memory in this buffer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>destination</code> - The <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a> to write into.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer.</dd>
</dl>
</li>
</ul>
<a id="readBytes(byte[],int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readBytes</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;readBytes&#8203;(byte[]&nbsp;destination,
                         int&nbsp;destPos,
                         int&nbsp;length)</pre>
<div class="block">Read from this buffer, into the destination array, the given number of bytes.
 This updates the <a href="#readerOffset()">read offset</a> of this buffer by the length argument.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>destination</code> - The byte array to write into.</dd>
<dd><code>destPos</code> - Position in the <code>destination</code> to where bytes should be written from this buffer.</dd>
<dd><code>length</code> - The number of bytes to copy.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer.</dd>
</dl>
</li>
</ul>
<a id="resetOffsets()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resetOffsets</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;resetOffsets()</pre>
<div class="block">Resets the <a href="#readerOffset()">read offset</a> and the <a href="#writerOffset()">write offset</a> on this
 buffer to zero, and return this buffer.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer instance.</dd>
</dl>
</li>
</ul>
<a id="bytesBefore(byte)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bytesBefore</h4>
<pre class="methodSignature">int&nbsp;bytesBefore&#8203;(byte&nbsp;needle)</pre>
<div class="block">Get the number of <a href="#readableBytes()">readable bytes</a>, until the given <code>needle</code> is found in this
 buffer.
 If the needle is not found, <code>-1</code> is returned.
 <p>
 This method does not modify the <a href="#readerOffset()">reader-offset</a> or the
 <a href="#writerOffset()">write-offset</a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>needle</code> - The byte value to search for.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The offset, relative to the current <a href="#readerOffset()"><code>readerOffset()</code></a>, of the found value, or <code>-1</code> if none
 was found.</dd>
</dl>
</li>
</ul>
<a id="bytesBefore(io.netty5.buffer.api.Buffer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>bytesBefore</h4>
<pre class="methodSignature">int&nbsp;bytesBefore&#8203;(<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;needle)</pre>
<div class="block">Get the number of <a href="#readableBytes()">readable bytes</a>, until the given <code>needle</code> is found in this
 buffer.
 The found offset will be the offset into this buffer, relative to its <a href="#readerOffset()">reader-offset</a>,
 of the first byte of a sequence that matches all readable bytes in the given <code>needle</code> buffer.
 If the needle is not found, <code>-1</code> is returned.
 <p>
 This method does not modify the <a href="#readerOffset()">reader-offset</a> or the
 <a href="#writerOffset()">write-offset</a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>needle</code> - The buffer value to search for.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The offset, relative to the current <a href="#readerOffset()"><code>readerOffset()</code></a>, of the found value, or <code>-1</code> if none
 was found.</dd>
</dl>
</li>
</ul>
<a id="openCursor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openCursor</h4>
<pre class="methodSignature"><a href="ByteCursor.html" title="interface in io.netty5.buffer.api">ByteCursor</a>&nbsp;openCursor()</pre>
<div class="block">Opens a cursor to iterate the readable bytes of this buffer. The <a href="#readerOffset()">reader offset</a> and
 <a href="#writerOffset()">writer offset</a> are not modified by the cursor.
 <p>
 Care should be taken to ensure that the buffer's lifetime extends beyond the cursor and the iteration, and that
 the <a href="#readerOffset()">reader offset</a> and <a href="#writerOffset()">writer offset</a> are not modified
 while the iteration takes place. Otherwise, unpredictable behaviour might result.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="ByteCursor.html" title="interface in io.netty5.buffer.api"><code>ByteCursor</code></a> for iterating the readable bytes of this buffer.</dd>
</dl>
</li>
</ul>
<a id="openCursor(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openCursor</h4>
<pre class="methodSignature"><a href="ByteCursor.html" title="interface in io.netty5.buffer.api">ByteCursor</a>&nbsp;openCursor&#8203;(int&nbsp;fromOffset,
                      int&nbsp;length)</pre>
<div class="block">Opens a cursor to iterate the given number bytes of this buffer, starting at the given offset.
 The <a href="#readerOffset()">reader offset</a> and <a href="#writerOffset()">writer offset</a> are not modified by
 the cursor.
 <p>
 Care should be taken to ensure that the buffer's lifetime extends beyond the cursor and the iteration, and that
 the <a href="#readerOffset()">reader offset</a> and <a href="#writerOffset()">writer offset</a> are not modified
 while the iteration takes place. Otherwise, unpredictable behaviour might result.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>fromOffset</code> - The offset into the buffer where iteration should start.
                  The first byte read from the iterator will be the byte at this offset.</dd>
<dd><code>length</code> - The number of bytes to iterate.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="ByteCursor.html" title="interface in io.netty5.buffer.api"><code>ByteCursor</code></a> for the given stretch of bytes of this buffer.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalArgumentException</a></code> - if the length is negative, or if the region given by the <code>fromOffset</code> and
 the <code>length</code> reaches outside the bounds of this buffer.</dd>
</dl>
</li>
</ul>
<a id="openReverseCursor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openReverseCursor</h4>
<pre class="methodSignature">default&nbsp;<a href="ByteCursor.html" title="interface in io.netty5.buffer.api">ByteCursor</a>&nbsp;openReverseCursor()</pre>
<div class="block">Opens a cursor to iterate the readable bytes of this buffer, in reverse.
 The <a href="#readerOffset()">reader offset</a> and <a href="#writerOffset()">writer offset</a> are not modified by
 the cursor.
 <p>
 Care should be taken to ensure that the buffer's lifetime extends beyond the cursor and the iteration, and that
 the <a href="#readerOffset()">reader offset</a> and <a href="#writerOffset()">writer offset</a> are not modified
 while the iteration takes place. Otherwise, unpredictable behaviour might result.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="ByteCursor.html" title="interface in io.netty5.buffer.api"><code>ByteCursor</code></a> for the readable bytes of this buffer.</dd>
</dl>
</li>
</ul>
<a id="openReverseCursor(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>openReverseCursor</h4>
<pre class="methodSignature"><a href="ByteCursor.html" title="interface in io.netty5.buffer.api">ByteCursor</a>&nbsp;openReverseCursor&#8203;(int&nbsp;fromOffset,
                             int&nbsp;length)</pre>
<div class="block">Opens a cursor to iterate the given number bytes of this buffer, in reverse, starting at the given offset.
 The <a href="#readerOffset()">reader offset</a> and <a href="#writerOffset()">writer offset</a> are not modified by
 the cursor.
 <p>
 Care should be taken to ensure that the buffer's lifetime extends beyond the cursor and the iteration, and that
 the <a href="#readerOffset()">reader offset</a> and <a href="#writerOffset()">writer offset</a> are not modified
 while the iteration takes place. Otherwise, unpredictable behaviour might result.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>fromOffset</code> - The offset into the buffer where iteration should start.
                  The first byte read from the iterator will be the byte at this offset.</dd>
<dd><code>length</code> - The number of bytes to iterate.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A <a href="ByteCursor.html" title="interface in io.netty5.buffer.api"><code>ByteCursor</code></a> for the given stretch of bytes of this buffer.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalArgumentException</a></code> - if the length is negative, or if the region given by the <code>fromOffset</code> and
 the <code>length</code> reaches outside the bounds of this buffer.</dd>
</dl>
</li>
</ul>
<a id="ensureWritable(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ensureWritable</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;ensureWritable&#8203;(int&nbsp;size)</pre>
<div class="block">Ensures that this buffer has at least the given number of bytes of
 <a href="#writableBytes()">available space for writing</a>.
 If this buffer already has the necessary space, then this method returns immediately.
 If this buffer does not already have the necessary space, then it will be expanded using the
 <a href="BufferAllocator.html" title="interface in io.netty5.buffer.api"><code>BufferAllocator</code></a> the buffer was created with.
 This method is the same as calling <a href="#ensureWritable(int,int,boolean)"><code>ensureWritable(int, int, boolean)</code></a> where <code>allowCompaction</code> is
 <code>true</code>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>size</code> - The requested number of bytes of space that should be available for writing.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer instance.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalStateException</a></code> - if this buffer is in a bad state.</dd>
<dd><code><a href="BufferClosedException.html" title="class in io.netty5.buffer.api">BufferClosedException</a></code> - if this buffer is closed.</dd>
<dd><code><a href="BufferReadOnlyException.html" title="class in io.netty5.buffer.api">BufferReadOnlyException</a></code> - if this buffer is <a href="#readOnly()">read-only</a>.</dd>
</dl>
</li>
</ul>
<a id="ensureWritable(int,int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ensureWritable</h4>
<pre class="methodSignature"><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;ensureWritable&#8203;(int&nbsp;size,
                      int&nbsp;minimumGrowth,
                      boolean&nbsp;allowCompaction)</pre>
<div class="block">Ensures that this buffer has at least the given number of bytes of
 <a href="#writableBytes()">available space for writing</a>.
 If this buffer already has the necessary space, then this method returns immediately.
 If this buffer does not already have the necessary space, then space will be made available in one or all of
 the following available ways:

 <ul>
     <li>
         If <code>allowCompaction</code> is <code>true</code>, and sum of the read and writable bytes would be enough to
         satisfy the request, and it (depending on the buffer implementation) seems faster and easier to compact
         the existing buffer rather than allocation a new buffer, then the requested bytes will be made available
         that way. The compaction will not necessarily work the same way as the <a href="#compact()"><code>compact()</code></a> method, as the
         implementation may be able to make the requested bytes available with less effort than is strictly
         mandated by the <a href="#compact()"><code>compact()</code></a> method.
     </li>
     <li>
         Regardless of the value of the <code>allowCompaction</code>, the implementation may make more space available
         by just allocating more or larger buffers. This allocation would use the same <a href="BufferAllocator.html" title="interface in io.netty5.buffer.api"><code>BufferAllocator</code></a>
         that this buffer was created with.
     </li>
     <li>
         If <code>allowCompaction</code> is <code>true</code>, then the implementation may choose to do a combination of
         compaction and allocation.
     </li>
 </ul></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>size</code> - The requested number of bytes of space that should be available for writing.</dd>
<dd><code>minimumGrowth</code> - The minimum number of bytes to grow by. If it is determined that memory should be allocated
                     and copied, make sure that the new memory allocation is bigger than the old one by at least
                     this many bytes. This way, the buffer can grow by more than what is immediately necessary,
                     thus amortising the costs of allocating and copying.</dd>
<dd><code>allowCompaction</code> - <code>true</code> if the method is allowed to modify the
                                   <a href="#readerOffset()">reader offset</a> and
                                   <a href="#writerOffset()">writer offset</a>, otherwise <code>false</code>.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer instance.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="BufferReadOnlyException.html" title="class in io.netty5.buffer.api">BufferReadOnlyException</a></code> - if this buffer is <a href="#readOnly()">read-only</a>.</dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalArgumentException</a></code> - if <code>size</code> or <code>minimumGrowth</code> are negative.</dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalStateException</a></code> - if this buffer is in a bad state.</dd>
</dl>
</li>
</ul>
<a id="copy()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copy</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;copy()</pre>
<div class="block">Returns a copy of this buffer's readable bytes.
 Modifying the content of the returned buffer will not affect this buffers contents.
 The two buffers will maintain separate offsets. This method is identical to
 <code>buf.copy(buf.readerOffset(), buf.readableBytes())</code>.
 This method does not modify <a href="#readerOffset()"><code>readerOffset()</code></a> or <a href="#writerOffset()"><code>writerOffset()</code></a> of this buffer.
 <p>
 The copy is created with a <a href="#writerOffset()">write offset</a> equal to the length of the copied data,
 so that the entire contents of the copy is ready to be read.
 <p>
 The returned buffer will not be read-only, regardless of the <a href="#readOnly()">read-only state</a> of this
 buffer.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new buffer instance, with independent <a href="#readerOffset()"><code>readerOffset()</code></a> and <a href="#writerOffset()"><code>writerOffset()</code></a>,
 that contains a copy of the readable region of this buffer.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="BufferClosedException.html" title="class in io.netty5.buffer.api">BufferClosedException</a></code> - if this buffer is closed.</dd>
</dl>
</li>
</ul>
<a id="copy(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copy</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;copy&#8203;(int&nbsp;offset,
                    int&nbsp;length)</pre>
<div class="block">Returns a copy of the given region of this buffer.
 Modifying the content of the returned buffer will not affect this buffers contents.
 The two buffers will maintain separate offsets.
 This method does not modify <a href="#readerOffset()"><code>readerOffset()</code></a> or <a href="#writerOffset()"><code>writerOffset()</code></a> of this buffer.
 <p>
 The copy is created with a <a href="#writerOffset()">write offset</a> equal to the length of the copy,
 so that the entire contents of the copy is ready to be read.
 <p>
 The returned buffer will not be read-only, regardless of the <a href="#readOnly()">read-only state</a> of this
 buffer.
 This has the same effect as calling <a href="#copy(int,int,boolean)"><code>copy(int, int, boolean)</code></a> with a <code>false</code> read-only argument.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>offset</code> - The offset where copying should start from. This is the offset of the first byte copied.</dd>
<dd><code>length</code> - The number of bytes to copy, and the capacity of the returned buffer.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new buffer instance, with independent <a href="#readerOffset()"><code>readerOffset()</code></a> and <a href="#writerOffset()"><code>writerOffset()</code></a>,
 that contains a copy of the given region of this buffer.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalArgumentException</a></code> - if the <code>offset</code> or <code>length</code> reaches outside the bounds of the
 buffer.</dd>
<dd><code><a href="BufferClosedException.html" title="class in io.netty5.buffer.api">BufferClosedException</a></code> - if this buffer is closed.</dd>
</dl>
</li>
</ul>
<a id="copy(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copy</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;copy&#8203;(boolean&nbsp;readOnly)</pre>
<div class="block">Returns a copy of this buffer's readable bytes, with the given read-only setting.
 Modifying the content of the returned buffer will not affect this buffers contents.
 The two buffers will maintain separate offsets.
 This method does not modify <a href="#readerOffset()"><code>readerOffset()</code></a> or <a href="#writerOffset()"><code>writerOffset()</code></a> of this buffer.
 <p>
 The copy is created with a <a href="#writerOffset()">write offset</a> equal to the length of the copy,
 so that the entire contents of the copy is ready to be read.
 <p>
 The returned buffer will be read-only if, and only if, the <code>readOnly</code> argument is <code>true</code>, and it
 will not be read-only if the argument is <code>false</code>.
 This is the case regardless of the <a href="#readOnly()">read-only state</a> of this buffer.
 <p>
 If this buffer is read-only, and a read-only copy is requested, then implementations <em>may</em> use structural
 sharing and have both buffers backed by the same underlying memory.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>readOnly</code> - The desired <a href="#readOnly()"><code>readOnly()</code></a> state of the returned buffer.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new buffer instance, with independent <a href="#readerOffset()"><code>readerOffset()</code></a> and <a href="#writerOffset()"><code>writerOffset()</code></a>,
 that contains a copy of the given region of this buffer.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalArgumentException</a></code> - if the <code>offset</code> or <code>length</code> reaches outside the bounds of the
 buffer.</dd>
<dd><code><a href="BufferClosedException.html" title="class in io.netty5.buffer.api">BufferClosedException</a></code> - if this buffer is closed.</dd>
</dl>
</li>
</ul>
<a id="copy(int,int,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>copy</h4>
<pre class="methodSignature"><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;copy&#8203;(int&nbsp;offset,
            int&nbsp;length,
            boolean&nbsp;readOnly)</pre>
<div class="block">Returns a copy of the given region of this buffer.
 Modifying the content of the returned buffer will not affect this buffers contents.
 The two buffers will maintain separate offsets.
 This method does not modify <a href="#readerOffset()"><code>readerOffset()</code></a> or <a href="#writerOffset()"><code>writerOffset()</code></a> of this buffer.
 <p>
 The copy is created with a <a href="#writerOffset()">write offset</a> equal to the length of the copy,
 so that the entire contents of the copy is ready to be read.
 <p>
 The returned buffer will be read-only if, and only if, the <code>readOnly</code> argument is <code>true</code>, and it
 will not be read-only if the argument is <code>false</code>.
 This is the case regardless of the <a href="#readOnly()">read-only state</a> of this buffer.
 <p>
 If this buffer is read-only, and a read-only copy is requested, then implementations <em>may</em> use structural
 sharing and have both buffers backed by the same underlying memory.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>offset</code> - The offset where copying should start from. This is the offset of the first byte copied.</dd>
<dd><code>length</code> - The number of bytes to copy, and the capacity of the returned buffer.</dd>
<dd><code>readOnly</code> - The desired <a href="#readOnly()"><code>readOnly()</code></a> state of the returned buffer.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new buffer instance, with independent <a href="#readerOffset()"><code>readerOffset()</code></a> and <a href="#writerOffset()"><code>writerOffset()</code></a>,
 that contains a copy of the given region of this buffer.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalArgumentException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalArgumentException</a></code> - if the <code>offset</code> or <code>length</code> reaches outside the bounds of the
 buffer.</dd>
<dd><code><a href="BufferClosedException.html" title="class in io.netty5.buffer.api">BufferClosedException</a></code> - if this buffer is closed.</dd>
</dl>
</li>
</ul>
<a id="readSplit(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readSplit</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;readSplit&#8203;(int&nbsp;length)</pre>
<div class="block">Splits the buffer into two, at <code>length</code> number of bytes from the current
 <a href="#readerOffset()">readerOffset()</a> reader offset} position.
 <p>
 The region of this buffer that contain the previously read and readable bytes till the
 <code>readerOffset() + length</code> position, will be captured and returned in a new buffer,
 that will hold its own ownership of that region.
 This allows the returned buffer to be independently <a href="Resource.html#send()">sent</a> to other threads.
 <p>
 The returned buffer will change its <a href="#readerOffset()"><code>readerOffset()</code></a> to <code>readerOffset() + length</code>, and have its
 <a href="#writerOffset()"><code>writerOffset()</code></a> and <a href="#capacity()"><code>capacity()</code></a> both set to the <code>readerOffset() + length</code> position.
 <p>
 The memory region in the returned buffer will become inaccessible through this buffer. This buffer will have its
 capacity reduced by the capacity of the returned buffer, read offset will become zero and relative position of
 write offset will be preserved from the provided <code>readerOffset() + length</code> position,
 even though their position in memory remain unchanged.
 <p>
 Effectively, the following transformation takes place:
 <pre><code>
         This buffer, where offset = readerOffset() + length:
          +------------------------------------------+
         0|   |r/o    offset        |w/o             |cap
          +---+---------+-----------+----------------+
         /   /         / \          \                \
        /   /         /   \          \                \
       /   /         /     \          \                \
      /   /         /       \          \                \
     /   /         /         \          \                \
    +---+---------+           +----------+----------------+
    |   |r/o      |w/o &amp; cap  |r/o      w/o               |cap
    +---+---------+           +---------------------------+
    Returned buffer.                   This buffer.
 </code></pre>
 When the buffers are in this state, both of the split parts retain an atomic reference count on the
 underlying memory. This means that shared underlying memory will not be deallocated or returned to a pool, until
 all the split parts have been closed.
 <p>
 Composite buffers have it a little easier, in that at most only one of the constituent buffers will actually be
 split. If the split point lands perfectly between two constituent buffers, then a composite buffer can
 simply split its internal array in two.
 <p>
 Split buffers support all operations that normal buffers do, including <a href="#ensureWritable(int)"><code>ensureWritable(int)</code></a>.
 <p>
 See the <a href="#split">Splitting buffers</a> section for details.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new buffer with independent and exclusive ownership over the previously read and readable bytes from
 this buffer.</dd>
</dl>
</li>
</ul>
<a id="writeSplit(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeSplit</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;writeSplit&#8203;(int&nbsp;length)</pre>
<div class="block">Splits the buffer into two, at <code>length</code> number of bytes from the current
 <a href="#writerOffset()">writerOffset()</a> writer offset} position.
 <p>
 The region of this buffer that contain the previously read and readable bytes till the
 <code>writerOffset() + length</code> position, will be captured and returned in a new buffer,
 that will hold its own ownership of that region.
 This allows the returned buffer to be independently <a href="Resource.html#send()">sent</a> to other threads.
 <p>
 The returned buffer will change its <a href="#writerOffset()"><code>writerOffset()</code></a> to <code>writerOffset() + length</code>, and have its
 <a href="#writerOffset()"><code>writerOffset()</code></a> and <a href="#capacity()"><code>capacity()</code></a> both set to the <code>writerOffset() + length</code>.
 <p>
 The memory region in the returned buffer will become inaccessible through this buffer. This buffer will have its
 capacity reduced by the capacity of the returned buffer, read offset will become zero and relative position of
 write offset will be preserved from the provided <code>writerOffset() + length</code> position,
 even though their position in memory remain unchanged.
 <p>
 Effectively, the following transformation takes place:
 <pre><code>
         This buffer, where offset = writerOffset() + length:
          +------------------------------------------+
         0|   |r/o  |w/o  offset                     |cap
          +---+----+-------+-------------------------+
         /   /    /       / \                        \
        /   /    /       /   \                        \
       /   /    /       /     \                        \
      /   /    /       /       \                        \
     /   /    /       /         \                        \
    +---+----+-------+           +------------------------+
    |   |r/o  |w/o   | cap       |r/o &amp; w/o               |cap
    +---+----+-------+           +------------------------+
    Returned buffer.                   This buffer.
 </code></pre>
 When the buffers are in this state, both of the split parts retain an atomic reference count on the
 underlying memory. This means that shared underlying memory will not be deallocated or returned to a pool, until
 all the split parts have been closed.
 <p>
 Composite buffers have it a little easier, in that at most only one of the constituent buffers will actually be
 split. If the split point lands perfectly between two constituent buffers, then a composite buffer can
 simply split its internal array in two.
 <p>
 Split buffers support all operations that normal buffers do, including <a href="#ensureWritable(int)"><code>ensureWritable(int)</code></a>.
 <p>
 See the <a href="#split">Splitting buffers</a> section for details.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new buffer with independent and exclusive ownership over the previously read and readable bytes from
 this buffer.</dd>
</dl>
</li>
</ul>
<a id="split()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>split</h4>
<pre class="methodSignature">default&nbsp;<a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;split()</pre>
<div class="block">Splits the buffer into two, at the <a href="#writerOffset()">write offset</a> position.
 <p>
 The region of this buffer that contain the previously read and readable bytes, will be captured and returned in
 a new buffer, that will hold its own ownership of that region. This allows the returned buffer to be
 independently <a href="Resource.html#send()">sent</a> to other threads.
 <p>
 The returned buffer will adopt the <a href="#readerOffset()"><code>readerOffset()</code></a> of this buffer, and have its <a href="#writerOffset()"><code>writerOffset()</code></a>
 and <a href="#capacity()"><code>capacity()</code></a> both set to the equal to the write-offset of this buffer.
 <p>
 The memory region in the returned buffer will become inaccessible through this buffer. This buffer will have its
 capacity reduced by the capacity of the returned buffer, and the read and write offsets of this buffer will both
 become zero, even though their position in memory remain unchanged.
 <p>
 Effectively, the following transformation takes place:
 <pre><code>
         This buffer:
          +------------------------------------------+
         0|   |r/o                  |w/o             |cap
          +---+---------------------+----------------+
         /   /                     / \               \
        /   /                     /   \               \
       /   /                     /     \               \
      /   /                     /       \               \
     /   /                     /         \               \
    +---+---------------------+           +---------------+
    |   |r/o                  |w/o &amp; cap  |r/o &amp; w/o      |cap
    +---+---------------------+           +---------------+
    Returned buffer.                      This buffer.
 </code></pre>
 When the buffers are in this state, both of the split parts retain an atomic reference count on the
 underlying memory. This means that shared underlying memory will not be deallocated or returned to a pool, until
 all the split parts have been closed.
 <p>
 Composite buffers have it a little easier, in that at most only one of the constituent buffers will actually be
 split. If the split point lands perfectly between two constituent buffers, then a composite buffer can
 simply split its internal array in two.
 <p>
 Split buffers support all operations that normal buffers do, including <a href="#ensureWritable(int)"><code>ensureWritable(int)</code></a>.
 <p>
 See the <a href="#split">Splitting buffers</a> section for details.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new buffer with independent and exclusive ownership over the previously read and readable bytes from
 this buffer.</dd>
</dl>
</li>
</ul>
<a id="split(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>split</h4>
<pre class="methodSignature"><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;split&#8203;(int&nbsp;splitOffset)</pre>
<div class="block">Splits the buffer into two, at the given <code>splitOffset</code>.
 <p>
 The region of this buffer that precede the <code>splitOffset</code>, will be captured and returned in a new
 buffer, that will hold its own ownership of that region. This allows the returned buffer to be independently
 <a href="Resource.html#send()">sent</a> to other threads.
 <p>
 The returned buffer will adopt the <a href="#readerOffset()"><code>readerOffset()</code></a> and <a href="#writerOffset()"><code>writerOffset()</code></a> of this buffer,
 but truncated to fit within the capacity dictated by the <code>splitOffset</code>.
 <p>
 The memory region in the returned buffer will become inaccessible through this buffer. If the
 <a href="#readerOffset()"><code>readerOffset()</code></a> or <a href="#writerOffset()"><code>writerOffset()</code></a> of this buffer lie prior to the <code>splitOffset</code>,
 then those offsets will be moved forward, so they land on offset 0 after the split.
 <p>
 Effectively, the following transformation takes place:
 <pre><code>
         This buffer:
          +--------------------------------+
         0|               |splitOffset     |cap
          +---------------+----------------+
         /               / \               \
        /               /   \               \
       /               /     \               \
      /               /       \               \
     /               /         \               \
    +---------------+           +---------------+
    |               |cap        |               |cap
    +---------------+           +---------------+
    Returned buffer.            This buffer.
 </code></pre>
 When the buffers are in this state, both of the split parts retain an atomic reference count on the
 underlying memory. This means that shared underlying memory will not be deallocated or returned to a pool, until
 all the split parts have been closed.
 <p>
 Composite buffers have it a little easier, in that at most only one of the constituent buffers will actually be
 split. If the split point lands perfectly between two constituent buffers, then a composite buffer can
 simply split its internal array in two.
 <p>
 Split buffers support all operations that normal buffers do, including <a href="#ensureWritable(int)"><code>ensureWritable(int)</code></a>.
 <p>
 See the <a href="#split">Splitting buffers</a> section for details.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>splitOffset</code> - The offset into this buffer where it should be split. After the split, the data at this offset
                    will be at offset zero in this buffer.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A new buffer with independent and exclusive ownership over the bytes from the beginning to the given
 offset of this buffer.</dd>
</dl>
</li>
</ul>
<a id="compact()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compact</h4>
<pre class="methodSignature"><a href="Buffer.html" title="interface in io.netty5.buffer.api">Buffer</a>&nbsp;compact()</pre>
<div class="block">Discards the read bytes, and moves the buffer contents to the beginning of the buffer.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>This buffer instance.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code><a href="BufferReadOnlyException.html" title="class in io.netty5.buffer.api">BufferReadOnlyException</a></code> - if this buffer is <a href="#readOnly()">read-only</a>.</dd>
<dd><code><a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/IllegalStateException.html?is-external=true" title="class or interface in java.lang" class="externalLink">IllegalStateException</a></code> - if this buffer is in a bad state.</dd>
</dl>
</li>
</ul>
<a id="countComponents()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countComponents</h4>
<pre class="methodSignature">int&nbsp;countComponents()</pre>
<div class="block">Get the number of "components" in this buffer. For composite buffers, this is the number of transitive
 constituent buffers, while non-composite buffers only have one component.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The number of components in this buffer.</dd>
</dl>
</li>
</ul>
<a id="countReadableComponents()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countReadableComponents</h4>
<pre class="methodSignature">int&nbsp;countReadableComponents()</pre>
<div class="block">Get the number of "components" in this buffer, that are readable. These are the components that would be
 processed by <a href="#forEachReadable(int,io.netty5.buffer.api.ReadableComponentProcessor)"><code>forEachReadable(int, ReadableComponentProcessor)</code></a>. For composite buffers, this is the
 number of transitive constituent buffers that are readable, while non-composite buffers only have at most one
 readable component.
 <p>
 The number of readable components may be less than the <a href="#countComponents()"><code>component count</code></a>, if not all of
 them have readable data.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The number of readable components in this buffer.</dd>
</dl>
</li>
</ul>
<a id="countWritableComponents()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countWritableComponents</h4>
<pre class="methodSignature">int&nbsp;countWritableComponents()</pre>
<div class="block">Get the number of "components" in this buffer, that are writable. These are the components that would be
 processed by <a href="#forEachWritable(int,io.netty5.buffer.api.WritableComponentProcessor)"><code>forEachWritable(int, WritableComponentProcessor)</code></a>. For composite buffers, this is the
 number of transitive constituent buffers that are writable, while non-composite buffers only have at most one
 writable component.
 <p>
 The number of writable components may be less than the <a href="#countComponents()"><code>component count</code></a>, if not all of
 them have space for writing.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The number of writable components in this buffer.</dd>
</dl>
</li>
</ul>
<a id="forEachReadable(int,io.netty5.buffer.api.ReadableComponentProcessor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>forEachReadable</h4>
<pre class="methodSignature">&lt;E extends <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Exception.html?is-external=true" title="class or interface in java.lang" class="externalLink">Exception</a>&gt;&nbsp;int&nbsp;forEachReadable&#8203;(int&nbsp;initialIndex,
                                          <a href="ReadableComponentProcessor.html" title="interface in io.netty5.buffer.api">ReadableComponentProcessor</a>&lt;E&gt;&nbsp;processor)
                                   throws E extends <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Exception.html?is-external=true" title="class or interface in java.lang" class="externalLink">Exception</a></pre>
<div class="block">Processes all readable components of this buffer, and return the number of components processed.
 <p>
 The given <a href="ReadableComponentProcessor.html" title="interface in io.netty5.buffer.api">processor</a> is called for each readable component in this buffer,
 and passed a component index, for the given component in the iteration, and a <a href="ReadableComponent.html" title="interface in io.netty5.buffer.api"><code>ReadableComponent</code></a> object
 for accessing the data within the given component.
 <p>
 The component index is specific to the particular invocation of this method. The first call to the consumer will
 be passed the given initial index, and the next call will be passed the initial index plus one, and so on.
 <p>
 The <a href="ReadableComponentProcessor.html" title="interface in io.netty5.buffer.api">component processor</a> may stop the iteration at any time by returning
 <code>false</code>.
 This will cause the number of components processed to be returned as a negative number (to signal early return),
 and the number of components processed may then be less than the
 <a href="#countReadableComponents()">readable component count</a>.
 <p>
 <strong>Note</strong> that the <a href="ReadableComponent.html" title="interface in io.netty5.buffer.api"><code>ReadableComponent</code></a> instance passed to the consumer could be reused for
 multiple calls, so the data must be extracted from the component in the context of the iteration.
 <p>
 The <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a> instances obtained from the component, share lifetime with that internal component.
 This means they can be accessed as long as the internal memory store remain unchanged. Methods that may cause
 such changes are <a href="#split(int)"><code>split(int)</code></a>, <a href="#split()"><code>split()</code></a>, <a href="#readSplit(int)"><code>readSplit(int)</code></a>, <a href="#writeSplit(int)"><code>writeSplit(int)</code></a>,
 <a href="#compact()"><code>compact()</code></a>, <a href="#ensureWritable(int)"><code>ensureWritable(int)</code></a>, <a href="#ensureWritable(int,int,boolean)"><code>ensureWritable(int, int, boolean)</code></a>,
 and <a href="Resource.html#send()"><code>Resource.send()</code></a>.
 <p>
 The best way to ensure this doesn't cause any trouble, is to use the buffers directly as part of the iteration.
 <p>
 <strong>Note</strong> that the arrays, memory addresses, and byte buffers exposed as components by this method,
 should not be used for changing the buffer contents. Doing so may cause undefined behaviour.
 <p>
 Changes to position and limit of the byte buffers exposed via the processed components, are not reflected back to
 this buffer instance.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initialIndex</code> - The initial index of the component for iteration, and the index that will be passed to the
 first call to the <a href="ReadableComponentProcessor.html#process(int,io.netty5.buffer.api.ReadableComponent)">processor</a>.</dd>
<dd><code>processor</code> - The processor that will be used to process the buffer components.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The number of readable components processed, as a positive number if all readable components were
 processed, or as a negative number if the iteration was stopped because
 <a href="ReadableComponentProcessor.html#process(int,io.netty5.buffer.api.ReadableComponent)"><code>ReadableComponentProcessor.process(int, ReadableComponent)</code></a> returned <code>false</code>.
 In any case, the number of components processed may be less than <a href="#countComponents()"><code>countComponents()</code></a>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>E extends <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Exception.html?is-external=true" title="class or interface in java.lang" class="externalLink">Exception</a></code></dd>
</dl>
</li>
</ul>
<a id="forEachReadable()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>forEachReadable</h4>
<pre class="methodSignature">&lt;T extends <a href="ReadableComponent.html" title="interface in io.netty5.buffer.api">ReadableComponent</a> &amp; <a href="ComponentIterator.Next.html" title="interface in io.netty5.buffer.api">ComponentIterator.Next</a>&gt;&nbsp;<a href="ComponentIterator.html" title="interface in io.netty5.buffer.api">ComponentIterator</a>&lt;T&gt;&nbsp;forEachReadable()</pre>
<div class="block">Create a <a href="ComponentIterator.html" title="interface in io.netty5.buffer.api">component iterator</a> for all readable components in this buffer.
 <p>
 Unlike the <a href="#forEachReadable(int,io.netty5.buffer.api.ReadableComponentProcessor)"><code>forEachReadable(int, ReadableComponentProcessor)</code></a> method, this API permits <em>external</em>
 iteration of the components, while at the same time protecting the life-cycle of the buffer.
 <p>
 The typical code pattern for using this API looks like the following:
 <pre><code>
      try (var iteration = buffer.forEachReadable()) {
          for (var c = iteration.first(); c != null; c = c.next()) {
              ByteBuffer componentBuffer = c.readableBuffer();
              // ...
          }
      }
 </code></pre>
 Note the use of the <code>var</code> keyword for local variables, which are required for correctly expressing the
 generic types used in the iteration.
 Following this code pattern will ensure that the components, and their parent buffer, will be correctly
 life-cycled.
 <p>
 <strong>Note</strong> that the <a href="ReadableComponent.html" title="interface in io.netty5.buffer.api"><code>ReadableComponent</code></a> instances exposed by the iterator could be reused for
 multiple calls, so the data must be extracted from the component in the context of the iteration.
 <p>
 The <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a> instances obtained from the component, share lifetime with that internal component.
 This means they can be accessed as long as the internal memory store remain unchanged. Methods that may cause
 such changes are <a href="#split(int)"><code>split(int)</code></a>, <a href="#split()"><code>split()</code></a>, <a href="#readSplit(int)"><code>readSplit(int)</code></a>, <a href="#writeSplit(int)"><code>writeSplit(int)</code></a>,
 <a href="#compact()"><code>compact()</code></a>, <a href="#ensureWritable(int)"><code>ensureWritable(int)</code></a>, <a href="#ensureWritable(int,int,boolean)"><code>ensureWritable(int, int, boolean)</code></a>,
 and <a href="Resource.html#send()"><code>Resource.send()</code></a>.
 <p>
 The best way to ensure this doesn't cause any trouble, is to use the buffers directly as part of the iteration.
 <p>
 <strong>Note</strong> that the arrays, memory addresses, and byte buffers exposed as components by this method,
 should not be used for changing the buffer contents. Doing so may cause undefined behaviour.
 <p>
 Changes to position and limit of the byte buffers exposed via the processed components, are not reflected back to
 this buffer instance.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - An intersection type that presents both the <a href="ReadableComponent.html" title="interface in io.netty5.buffer.api"><code>ReadableComponent</code></a> interface,
          <em>and</em> the ability to progress the iteration via the <a href="ComponentIterator.Next.html#next()"><code>ComponentIterator.Next.next()</code></a> method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A component iterator of <a href="ReadableComponent.html" title="interface in io.netty5.buffer.api">readable components</a>.</dd>
</dl>
</li>
</ul>
<a id="forEachWritable(int,io.netty5.buffer.api.WritableComponentProcessor)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>forEachWritable</h4>
<pre class="methodSignature">&lt;E extends <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Exception.html?is-external=true" title="class or interface in java.lang" class="externalLink">Exception</a>&gt;&nbsp;int&nbsp;forEachWritable&#8203;(int&nbsp;initialIndex,
                                          <a href="WritableComponentProcessor.html" title="interface in io.netty5.buffer.api">WritableComponentProcessor</a>&lt;E&gt;&nbsp;processor)
                                   throws E extends <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Exception.html?is-external=true" title="class or interface in java.lang" class="externalLink">Exception</a></pre>
<div class="block">Process all writable components of this buffer, and return the number of components processed.
 <p>
 The given <a href="WritableComponentProcessor.html" title="interface in io.netty5.buffer.api">processor</a> is called for each writable component in this buffer,
 and passed a component index, for the given component in the iteration, and a <a href="WritableComponent.html" title="interface in io.netty5.buffer.api"><code>WritableComponent</code></a> object
 for accessing the data within the given component.
 <p>
 The component index is specific to the particular invocation of this method. The first call to the consumer will
 be passed the given initial index, and the next call will be passed the initial index plus one, and so on.
 <p>
 The <a href="WritableComponentProcessor.html" title="interface in io.netty5.buffer.api"><code>component processor</code></a> may stop the iteration at any time by returning
 <code>false</code>.
 This will cause the number of components processed to be returned as a negative number (to signal early return),
 and the number of components processed may then be less than the
 <a href="#countReadableComponents()">readable component count</a>.
 <p>
 <strong>Note</strong> that the <a href="WritableComponent.html" title="interface in io.netty5.buffer.api"><code>WritableComponent</code></a> instance passed to the consumer could be reused for
 multiple calls, so the data must be extracted from the component in the context of the iteration.
 <p>
 The <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a> instances obtained from the component, share lifetime with that internal component.
 This means they can be accessed as long as the internal memory store remain unchanged. Methods that may cause
 such changes are <a href="#split(int)"><code>split(int)</code></a>, <a href="#split()"><code>split()</code></a>, <a href="#readSplit(int)"><code>readSplit(int)</code></a>, <a href="#writeSplit(int)"><code>writeSplit(int)</code></a>,
 <a href="#compact()"><code>compact()</code></a>, <a href="#ensureWritable(int)"><code>ensureWritable(int)</code></a>, <a href="#ensureWritable(int,int,boolean)"><code>ensureWritable(int, int, boolean)</code></a>,
 and <a href="Resource.html#send()"><code>Resource.send()</code></a>.
 <p>
 The best way to ensure this doesn't cause any trouble, is to use the buffers directly as part of the iteration.
 <p>
 Changes to position and limit of the byte buffers exposed via the processed components, are not reflected back to
 this buffer instance.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>initialIndex</code> - The initial index of the component for iteration, and the index that will be passed to the
 first call to the <a href="WritableComponentProcessor.html#process(int,io.netty5.buffer.api.WritableComponent)">processor</a>.</dd>
<dd><code>processor</code> - The processor that will be used to process the buffer components.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The number of writable components processed, as a positive number if all writable components were
 processed, or as a negative number if the iteration was stopped because
 <a href="WritableComponentProcessor.html#process(int,io.netty5.buffer.api.WritableComponent)"><code>WritableComponentProcessor.process(int, WritableComponent)</code></a> returned <code>false</code>.
 In any case, the number of components processed may be less than <a href="#countComponents()"><code>countComponents()</code></a>.</dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>E extends <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Exception.html?is-external=true" title="class or interface in java.lang" class="externalLink">Exception</a></code></dd>
</dl>
</li>
</ul>
<a id="forEachWritable()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>forEachWritable</h4>
<pre class="methodSignature">&lt;T extends <a href="WritableComponent.html" title="interface in io.netty5.buffer.api">WritableComponent</a> &amp; <a href="ComponentIterator.Next.html" title="interface in io.netty5.buffer.api">ComponentIterator.Next</a>&gt;&nbsp;<a href="ComponentIterator.html" title="interface in io.netty5.buffer.api">ComponentIterator</a>&lt;T&gt;&nbsp;forEachWritable()</pre>
<div class="block">Create a <a href="ComponentIterator.html" title="interface in io.netty5.buffer.api">component iterator</a> for all writable components in this buffer.
 <p>
 Unlike the <a href="#forEachWritable(int,io.netty5.buffer.api.WritableComponentProcessor)"><code>forEachWritable(int, WritableComponentProcessor)</code></a> method, this API permits <em>external</em>
 iteration of the components, while at the same time protecting the life-cycle of the buffer.
 <p>
 The typical code pattern for using this API looks like the following:
 <pre><code>
      try (var iteration = buffer.forEachWritable()) {
          for (var c = iteration.first(); c != null; c = c.next()) {
              ByteBuffer componentBuffer = c.writableBuffer();
              // ...
          }
      }
 </code></pre>
 Note the use of the <code>var</code> keyword for local variables, which are required for correctly expressing the
 generic types used in the iteration.
 Following this code pattern will ensure that the components, and their parent buffer, will be correctly
 life-cycled.
 <p>
 <strong>Note</strong> that the <a href="WritableComponent.html" title="interface in io.netty5.buffer.api"><code>WritableComponent</code></a> instances exposed by the iterator could be reused for
 multiple calls, so the data must be extracted from the component in the context of the iteration.
 <p>
 The <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/ByteBuffer.html?is-external=true" title="class or interface in java.nio" class="externalLink"><code>ByteBuffer</code></a> instances obtained from the component, share lifetime with that internal component.
 This means they can be accessed as long as the internal memory store remain unchanged. Methods that may cause
 such changes are <a href="#split(int)"><code>split(int)</code></a>, <a href="#split()"><code>split()</code></a>, <a href="#readSplit(int)"><code>readSplit(int)</code></a>, <a href="#writeSplit(int)"><code>writeSplit(int)</code></a>,
 <a href="#compact()"><code>compact()</code></a>, <a href="#ensureWritable(int)"><code>ensureWritable(int)</code></a>, <a href="#ensureWritable(int,int,boolean)"><code>ensureWritable(int, int, boolean)</code></a>,
 and <a href="Resource.html#send()"><code>Resource.send()</code></a>.
 <p>
 The best way to ensure this doesn't cause any trouble, is to use the buffers directly as part of the iteration.
 <p>
 <strong>Note</strong> that the arrays, memory addresses, and byte buffers exposed as components by this method,
 should not be used for changing the buffer contents beyond the respective array offset and length,
 or buffer position and limit. Doing so may cause undefined behaviour.
 <p>
 Changes to position and limit of the byte buffers exposed via the processed components, are not reflected back to
 this buffer instance.</div>
<dl>
<dt><span class="paramLabel">Type Parameters:</span></dt>
<dd><code>T</code> - An intersection type that presents both the <a href="ReadableComponent.html" title="interface in io.netty5.buffer.api"><code>ReadableComponent</code></a> interface,
          <em>and</em> the ability to progress the iteration via the <a href="ComponentIterator.Next.html#next()"><code>ComponentIterator.Next.next()</code></a> method.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>A component iterator of <a href="ReadableComponent.html" title="interface in io.netty5.buffer.api">readable components</a>.</dd>
</dl>
</li>
</ul>
<a id="toString(java.nio.charset.Charset)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>toString</h4>
<pre class="methodSignature">default&nbsp;<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/String.html?is-external=true" title="class or interface in java.lang" class="externalLink">String</a>&nbsp;toString&#8203;(<a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/Charset.html?is-external=true" title="class or interface in java.nio.charset" class="externalLink">Charset</a>&nbsp;charset)</pre>
<div class="block">Decodes this buffer's readable bytes into a string with the specified <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/nio/charset/Charset.html?is-external=true" title="class or interface in java.nio.charset" class="externalLink">Charset</a>.
 <p>
 This method does not modify the reader or writer offset of this buffer.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>charset</code> - used for decoding.</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Buffer's readable bytes as a string.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="../../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Buffer.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../../../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 2008&#x2013;2022 <a href="https://netty.io/">The Netty Project</a>. All rights reserved.</small></p>
</footer>
</body>
</html>
